#' Get data from a SQLite-database.
#' 
#' this function can be used to obtain data from a local or remote SQLite database. If the full path with filename is provided in 'SQLiteDB', it will look for that SQLite-file locally. If 'SQLiteDB' is NULL it will establish a connection with a remote server. There is also functionality to use an existing opened data base connection that can be provided in 'use_connection'. For instance, when creating residence patches within a loop of tags and tide ID's. Because establishing a conncection within a for-loop takes a long time, an established connection can be used.
#' @author Pratik R. Gupte & Allert I. Bijleveld
#' @param tag An 11 digit number representing the ATLAS tag. May be passed as a character or a numeric, and will be converted to a character. For example \code{"31001000001"}.
#' @param tracking_time_start Character representation of time from which start-point data should be retrieved.
#' @param tracking_time_end Character time representing the end point corresponding to the above start point.
#' @param timezone Timezone of tracking_time_start and tracking_time_end. Must be a valid timezone for the as.POSIXct function. 
#' @param database The database name on the host server.
#' @param host The server address on which the data are stored.
#' @param username Username to access the server.
#' @param password Password to access the server.
#' @param SQLiteDB The full path including the filename of a local SQLite-database whith tracking data. This argument overrules establishing a connection with the remote host. 
#' @param use_connection An R-object with a previously established connection, for instance generated by \code{RMySQL::dbConnect(RMySQL::MySQL(), user = 'username', password = 'password', dbname = 'database', host = 'host')}. This argument overrules making a connection to a local host \code{SQLiteDB} or a remote host.
#' @returns A dataframe of localizations of the specified tag, filtered between the start and end times.\cr
#' PosID	=	Unique number for localizations \cr
#' TAG 		=	11 digit WATLAS tag ID \cr
#' tag		=	4 digit tag number (character) \cr
#' TIME		=	UNIX time (seconds) \cr
#' time 	= 	Timestamp in POSIXct (UTC) \cr
#' X		=	X-ccordinates in meters (utm 31 N) \cr
#' Y		=	Y-ccordinates in meters (utm 31 N) \cr	
#' NBS		=	Number of Base Stations used in calculating coordinates \cr 
#' VARX		=	Variance in estimating X-coordinates \cr
#' VARY		=	Variance in estimating Y-coordinates \cr
#' COVXY	=	Co-variance between X- and Y-coordinates \cr
#' @import RMySQL
#' @export
#'
atl_get_data<-
function (tag, tracking_time_start, tracking_time_end, timezone = "CET", 
    database = "some_database", host = "some.host.nl", 
    username = "someuser", password = "somepassword", SQLiteDB=NULL, use_connection=NULL) 
{		
	## check input
	assertthat::assert_that(any(is.numeric(tag), is.character(tag)), 
        msg = "tag provided must be numeric or character")
    assertthat::assert_that(is.character(tracking_time_start), 
        msg = "start tracking time is not a character")
    assertthat::assert_that(is.character(tracking_time_end), 
        msg = "end tracking time is not a character")
    assertthat::assert_that(nchar(as.character(tag)) == 11, msg = glue::glue("tag is not 11 digits, \\\n                                           rather {nchar(tag)} digits"))
    assertthat::assert_that(is.character(timezone), msg = "timezone provided must be numeric or character")
    db_params <- c(host, username, password)
    purrr::walk(db_params, function(this_param) {
        assertthat::assert_that(is.character(this_param), msg = glue::glue("{this_param} is not a character"))
    })
	
	## process parameters 
    tracking_time_start <- as.POSIXct(tracking_time_start, tz = timezone)
    tracking_time_end <- as.POSIXct(tracking_time_end, tz = timezone)
    attributes(tracking_time_start)$tzone <- "UTC"
    attributes(tracking_time_end)$tzone <- "UTC"
    tracking_time_start <- as.numeric(tracking_time_start) * 
        1000
    tracking_time_end <- as.numeric(tracking_time_end) * 1000
    
	## get data 
	sql_query <- glue::glue("select TAG, TIME, X, Y, NBS, VARX, VARY, COVXY\n    FROM LOCALIZATIONS\n    WHERE TAG IN ({glue::glue_collapse(tag, sep = ',')})\n      AND TIME > {`tracking_time_start`}\n      AND TIME < {`tracking_time_end`}\n    ORDER BY TIME ASC")
		
	## make new connecvtion or use existing
	if (is.null(use_connection)){
		## from server or file	
		if(is.null(SQLiteDB)){
			## from server database  
				mydb <- RMySQL::dbConnect(RMySQL::MySQL(), user = username, 
					password = password, dbname = database, host = host)
				tmp_data <- DBI::dbGetQuery(mydb, sql_query)
			}else{
			## connect to SQLite databse file 
			mydb <- RSQLite::dbConnect(RSQLite::SQLite(),SQLiteDB) 
			tmp_data <- RSQLite::dbGetQuery(mydb, sql_query)	
			}
		 RMySQL::dbDisconnect(mydb) ## close connection
   		}else{
			tmp_data <- DBI::dbGetQuery(use_connection, sql_query) # open data with existing connection 
			}

	## recalculate time to seconds (instaed of miliseconds and add a column with timestamp in UTC 
	if(nrow(tmp_data) > 0){
			tmp_data <-tmp_data %>%
				dplyr::mutate(TIME = TIME/1000, time = as.POSIXct(TIME, origin = "1970-01-01", tz="UTC"))
			tmp_data$posID<-1:dim(tmp_data)[1]
			tmp_data$tag<-stringr::str_pad(as.character(substr(tmp_data$TAG, 8,11)), 4, pad = "0")
			return(tmp_data[,c("posID", "TAG", "tag", "TIME", "time", "X", "Y", "NBS", "VARX", "VARY", "COVXY")])
			}else{
			warning("no data available for this tag in this time period")
			return(tmp_data)
			}	
    }
	
